---
title: "Building a Secure Corporate Platform: Beuni DevSecOps Journey"
description: "Deep dive into implementing enterprise-grade security in a full-stack birthday management platform with 92% test coverage and zero critical vulnerabilities."
date: "2025-10-06"
readTime: "12 min read"
category: "DevSecOps"
author: "zer0spin"
featured: true
coverImage: "/images/projects/beuni.webp"
tags: ["devsecops", "nextjs", "security", "testing", "ci-cd"]
---

When tasked with building a corporate birthday management platform, I didn't just aim for functionality—I aimed for **production-grade security from day one**. Here's how I implemented DevSecOps practices to achieve 92% test coverage and zero critical vulnerabilities.

---

## The Challenge

The Beuni platform needed to:
- **Manage employee data** (PII handling)
- **Automate gift sending** (business logic complexity)
- **Track shipments** (7-business-day SLA)
- **Provide analytics** (executive dashboards)
- **Scale securely** (multi-tenant architecture)

**Security wasn't optional—it was foundational.**

---

## Architecture: Security by Design

### Tech Stack Selection

**Frontend**: Next.js 14 + TypeScript
- Type safety prevents entire classes of bugs
- Server-side rendering reduces client-side attack surface
- Built-in security headers via middleware

**Backend**: NestJS 10 + TypeScript
- Dependency injection enables secure service boundaries
- Guard decorators enforce authentication/authorization
- Exception filters prevent information leakage

**Database**: PostgreSQL 15 + Prisma ORM
- Parameterized queries prevent SQL injection
- Row-level security (RLS) for multi-tenancy
- Database-level constraints enforce data integrity

**Cache Layer**: Redis
- Performance optimization with secure caching
- Session management
- Real-time data optimization

**Infrastructure**: Docker + Railway (Backend) + Vercel (Frontend)
- Immutable containers reduce configuration drift
- Environment isolation per deployment
- Automated rollbacks on health check failures

---

## Security Implementations

### 1. Authentication & Authorization

**JWT with httpOnly Cookies**:
```typescript
// Never expose tokens to JavaScript
res.cookie('access_token', token, {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'strict',
  maxAge: 3600000 // 1 hour
});
```

**Why httpOnly cookies?**
- ✅ Immune to XSS attacks
- ✅ Automatic transmission (no manual token management)
- ✅ Browser handles storage securely

**Role-Based Access Control (RBAC)**:
```typescript
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles('admin', 'manager')
@Delete('shipments/bulk')
async bulkDelete(@Request() req) {
  // Organization-scoped deletion
  return this.shipmentService.bulkDelete(
    req.body.ids,
    req.user.organizationId
  );
}
```

**Key principle**: Every operation is **organization-scoped** to prevent cross-tenant data access.

---

### 2. CSRF Protection

**Problem**: Authenticated requests can be forged from malicious sites.

**Solution**: Cryptographically secure CSRF tokens
```typescript
import crypto from 'crypto';

// Generate unpredictable token
const csrfToken = crypto.randomBytes(32).toString('hex');

// Validate on state-changing operations
if (req.body.csrfToken !== req.session.csrfToken) {
  throw new ForbiddenException('Invalid CSRF token');
}
```

**Defense in depth**:
- SameSite cookies (first line)
- CSRF tokens (second line)
- Origin validation (third line)

---

### 3. Input Validation & Sanitization

**Every input is untrusted**:
```typescript
import { IsEmail, IsNotEmpty, MaxLength } from 'class-validator';

export class CreateEmployeeDto {
  @IsNotEmpty()
  @MaxLength(100)
  name: string;

  @IsEmail()
  email: string;

  @IsDateString()
  birthDate: string;
}
```

**Backend validation is mandatory** even with frontend validation:
- Clients can be bypassed
- API endpoints can be called directly
- Validation errors provide early feedback

---

### 4. Security Headers (Helmet.js)

**Production configuration**:
```typescript
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'"], // No inline scripts
      styleSrc: ["'self'", "'unsafe-inline'"], // CSS-in-JS compatibility
      imgSrc: ["'self'", 'data:', 'https:'],
      connectSrc: ["'self'", process.env.FRONTEND_URL]
    }
  },
  hsts: {
    maxAge: 31536000, // 1 year
    includeSubDomains: true,
    preload: true
  },
  frameguard: { action: 'deny' }, // Prevent clickjacking
  noSniff: true, // Prevent MIME sniffing
  xssFilter: true // XSS protection
}));
```

**HSTS** forces HTTPS, preventing man-in-the-middle attacks.

---

### 5. Secrets Management

**Never commit secrets**:
```bash
# .env files are gitignored
JWT_SECRET=<generated-via-crypto>
DATABASE_URL=postgresql://...
REDIS_URL=redis://...
```

**Environment validation at startup**:
```typescript
if (!process.env.JWT_SECRET) {
  throw new Error('JWT_SECRET must be defined');
}
```

**Application fails fast** if configuration is insecure.

---

## Testing Strategy: 92% Coverage

### Unit Tests (Backend Services)

**Example: Shipment deletion with organization scoping**
```typescript
describe('ShipmentService.bulkDelete', () => {
  it('should only delete shipments from user organization', async () => {
    const result = await service.bulkDelete(
      [1, 2, 3],
      'org-123'
    );

    expect(result.deletedCount).toBe(2); // Only 2 belong to org-123
    expect(prisma.shipment.deleteMany).toHaveBeenCalledWith({
      where: {
        id: { in: [1, 2, 3] },
        organizationId: 'org-123' // Organization scoped
      }
    });
  });
});
```

**What we test**:
- Authorization boundaries
- Edge cases (empty arrays, invalid IDs)
- Error handling
- Business logic correctness

---

### Integration Tests (API Endpoints)

**Example: CSRF protection**
```typescript
describe('POST /api/shipments', () => {
  it('should reject requests without CSRF token', async () => {
    const response = await request(app)
      .post('/api/shipments')
      .set('Cookie', validAuthCookie)
      .send({ ... });

    expect(response.status).toBe(403);
    expect(response.body.message).toContain('CSRF');
  });

  it('should accept requests with valid CSRF token', async () => {
    const response = await request(app)
      .post('/api/shipments')
      .set('Cookie', validAuthCookie)
      .send({ csrfToken: validToken, ... });

    expect(response.status).toBe(201);
  });
});
```

---

### E2E Tests (Critical Flows)

**Example: Employee birthday gift workflow**
```typescript
test('should send gift 7 business days before birthday', async () => {
  // Arrange: Create employee with birthday in 10 days
  await createEmployee({ birthDate: '2024-10-22' });

  // Act: Run scheduled job
  await runGiftScheduler();

  // Assert: Shipment created for correct date
  const shipment = await getShipment();
  expect(shipment.scheduledDate).toBe('2024-10-15'); // 7 business days before
});
```

**Coverage breakdown**:
- Overall Coverage: **92%**
- Backend services: **95%** (NestJS + Jest)
- Frontend components: **88%** (Next.js + Vitest)
- API endpoints: **94%**
- Integration flows: **90%**

---

## CI/CD Pipeline: Automated Security

### GitHub Actions Workflow

```yaml
name: DevSecOps Pipeline

on: [push, pull_request]

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Dependency audit
        run: npm audit --audit-level=high

      - name: SAST scan
        run: npm run lint:security

      - name: Secret scanning
        uses: trufflesecurity/trufflehog@main

  test:
    runs-on: ubuntu-latest
    steps:
      - name: Unit tests
        run: npm test

      - name: Coverage report
        run: npm run test:coverage

      - name: Fail if coverage &lt; 80%
        run: |
          COVERAGE=$(grep -oP '(?<=All files\s+\|\s+)\d+' coverage/coverage-summary.txt)
          if [ $COVERAGE -lt 80 ]; then exit 1; fi

  build:
    runs-on: ubuntu-latest
    needs: [security-scan, test]
    steps:
      - name: Build frontend
        run: npm run build:frontend

      - name: Build backend
        run: npm run build:backend

      - name: Deploy to Railway (production)
        if: github.ref == 'refs/heads/main'
        run: railway up
```

**Pipeline enforces**:
- No critical vulnerabilities
- Passing tests
- 80%+ coverage
- Successful builds

**Deployments are blocked** if any stage fails.

---

## Vulnerability Management

### Dependency Scanning

**Automated weekly audits**:
```bash
npm audit --audit-level=moderate
```

**Results**:
- ✅ **Zero critical vulnerabilities**
- ✅ **Zero high vulnerabilities**
- ✅ 2 moderate (accepted risk, documented)

**Immediate patching** for anything high/critical.

---

### OWASP Top 10 Compliance

| Vulnerability | Mitigation |
| :------------ | :--------- |
| **A01:2021 – Broken Access Control** | RBAC + organization scoping |
| **A02:2021 – Cryptographic Failures** | HTTPS + encrypted storage |
| **A03:2021 – Injection** | Parameterized queries + validation |
| **A04:2021 – Insecure Design** | Threat modeling + secure defaults |
| **A05:2021 – Security Misconfiguration** | Helmet.js + least privilege |
| **A06:2021 – Vulnerable Components** | Automated dependency scanning |
| **A07:2021 – Authentication Failures** | JWT + httpOnly cookies + MFA ready |
| **A08:2021 – Data Integrity Failures** | CSRF + integrity checks |
| **A09:2021 – Logging Failures** | Centralized logging + alerting |
| **A10:2021 – SSRF** | Allowlist-based validation |

**Every OWASP category addressed** during design and implementation.

---

## Performance & Security Balance

### Redis Caching

**Reduce database load without compromising security**:
```typescript
@Cacheable({ ttl: 300 }) // 5 minutes
async getEmployeeBirthdays(organizationId: string) {
  // Organization-scoped query (security)
  // Cached result (performance)
  return this.prisma.employee.findMany({
    where: { organizationId },
    select: { id: true, name: true, birthDate: true }
  });
}
```

**Cache invalidation** on mutations ensures data consistency.

---

### Database Indexing

**Security-optimized indexes**:
```sql
-- Organization-scoped queries are fast
CREATE INDEX idx_shipments_org_id ON shipments(organization_id);

-- Prevent timing attacks on email lookups
CREATE INDEX idx_users_email_hash ON users(SHA256(email));
```

**Performance doesn't compromise security.**

---

## Lessons Learned

### What Worked

✅ **Security from Day 1**: Retrofitting security is painful  
✅ **Automated Testing**: Catches regressions immediately  
✅ **Type Safety**: Prevents entire bug classes  
✅ **Defense in Depth**: Multiple security layers  
✅ **Fail Fast**: Invalid config = no startup

### What I'd Do Differently

⚠️ **Earlier threat modeling**: Would have caught edge cases sooner  
⚠️ **More E2E tests**: Integration tests are valuable but insufficient  
⚠️ **Security documentation**: Should be written alongside code

---

## The Numbers

**Development Timeline**: Active development (October 2025)
**Test Coverage**: 92%
**Critical Vulnerabilities**: 0
**High Vulnerabilities**: 0
**Managed Files**: 500+
**Recent Activity**: 35 commits in last 24 hours
**Deployment Success Rate**: 100%
**Security Rating**: A+

**Uptime**: 99.9% (production)

---

## Key Takeaways

1. **Security is not a feature—it's a foundation**
2. **Automate everything** (tests, scans, deployments)
3. **Organization scoping** prevents 90% of access control bugs
4. **httpOnly cookies** &gt; localStorage for tokens
5. **CSRF protection** is mandatory for state-changing operations
6. **Helmet.js** gives enterprise security headers for free
7. **92% coverage** is achievable with discipline

**DevSecOps isn't optional—it's table stakes for production systems.**

---

## Links

- **GitHub**: [github.com/zer0spin/beuni-desafio](https://github.com/zer0spin/beuni-desafio)
- **Live Demo**: [beuni-frontend-one.vercel.app](https://beuni-frontend-one.vercel.app)
- **Architecture Docs**: [docs/ARCHITECTURE.md](https://github.com/zer0spin/beuni-desafio/blob/main/docs/project/ARCHITECTURE.md)
- **Security Policy**: [SECURITY.md](https://github.com/zer0spin/beuni-desafio/blob/main/SECURITY.md)

---

**Building secure software isn't harder—it's different.** Start with security, not sprinkle it on top.

**What's your biggest DevSecOps challenge?** Let's discuss—security is a team sport.
